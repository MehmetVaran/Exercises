# Mehmet VARAN

#importing libraries
import pandas as pd
import string
import numpy as np
import scipy.sparse as sp
from sklearn.preprocessing import normalize
from sklearn.feature_extraction.text import TfidfTransformer, CountVectorizer
from sklearn import metrics
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from nltk.stem import PorterStemmer
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn import metrics as ms

#reading test data
data_test = pd.read_table("test.dat")

# reading train data
data_train = pd.read_table("train.dat")

# grouping train data by classes
data_train_per_class = data_train.groupby(['Disease Code'], as_index=False).agg({'Review': ' '.join})

# creating class based tfidf class
class CTFIDFVectorizer(TfidfTransformer):
    def __init__(self, *args, **kwargs):
        super(CTFIDFVectorizer, self).__init__(*args, **kwargs)

    def fit(self, X: sp.csr_matrix, n_samples: int):
        """Learn the idf vector (global term weights) """
        _, n_features = X.shape
        df = np.squeeze(np.asarray(X.sum(axis=0)))
        idf = np.log(n_samples / df)
        self._idf_diag = sp.diags(idf, offsets=0,
                                  shape=(n_features, n_features),
                                  format='csr',
                                  dtype=np.float64)
        return self

    def transform(self, X: sp.csr_matrix) -> sp.csr_matrix:
        """Transform a count-based matrix to c-TF-IDF """
        X = X * self._idf_diag
        X = normalize(X, axis=1, norm='l1', copy=False)
        return X
    

# applying ctfidf
count_vectorizer = CountVectorizer().fit(data_train_per_class.Review)
count = count_vectorizer.transform(data_train_per_class.Review)
ctfidf_vectorizer = CTFIDFVectorizer().fit(count, n_samples=len(data_train))
ctfidf = ctfidf_vectorizer.transform(count)

# predicting values from the test data
count = count_vectorizer.transform(data_test.Review)
vector = ctfidf_vectorizer.transform(count)
distances = cosine_similarity(vector, ctfidf)
prediction = np.argmax(distances, 1)

# converting predicted values (which are predicted by ctfidf) array to dataframe
data_predicted = pd.DataFrame(prediction)
data_predicted.rename(columns = {0:'Predicted'}, inplace=True)
data_predicted = data_predicted + 1 # doing this because after prediction values becomes 0-1-2-3-4 instead of 1-2-3-4-5

# concating predicted values and test data
data_ctfidf = pd.concat([data_test, data_predicted], axis=1)

# concating all the reviews on one dataframe
# because there are some words that does not exist both of the datas 
data_reviews = pd.concat([data_train.iloc[:,1:2], data_test], axis=0)

# convertingt to list
data_total = data_reviews['Review'].values.tolist()

# removing punctuations
data_cleaned = [headline.lower().translate(str.maketrans('', '', string.punctuation)) for headline in data_total]

# applying tfidf
vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(data_cleaned)

# converting to dataframe
sklearn_tfidf = pd.DataFrame(data = X.toarray(),columns=vectorizer.get_feature_names())

# stemming
stem = PorterStemmer()
data_stemmed = [" ".join([stem.stem(word) for word in sentence.split(" ")]) for sentence in data_cleaned]

# applying tfidf
vectorizer = TfidfVectorizer()
X_stemmed = vectorizer.fit_transform(data_stemmed)

# converting to dataframe
sklearn_tfidf_stemmed = pd.DataFrame(data = X_stemmed.toarray(),columns=vectorizer.get_feature_names())

# splittind data for classification 
X_train = sklearn_tfidf.iloc[0:14438,:]
Y_train = data_train.iloc[0:14438,0:1]
X_test = sklearn_tfidf.iloc[14438:28880,:]  # this is real test data
Y_test = data_predicted # this is predicted data from ctfidf
X_train_stemmed = sklearn_tfidf_stemmed.iloc[0:14438,:]
X_test_stemmed = sklearn_tfidf_stemmed.iloc[14438:28880,:]

# applying classification models
# Random forest without stemmed corpus
clf = RandomForestClassifier()
clf.fit(X_train,Y_train.values.ravel())

# Random forest with stemmed corpus
clf2 = RandomForestClassifier()
clf2.fit(X_train_stemmed,Y_train.values.ravel())

# Decision tree without stemmed corpus
dct = DecisionTreeClassifier()
dct.fit(X_train, Y_train.values.ravel())

# Decision tree with stemmed corpus
dct2 = DecisionTreeClassifier()
dct2.fit(X_train_stemmed,Y_train.values.ravel())

# KNN without stemmed corpus
knn = KNeighborsClassifier(n_neighbors=3)
knn.fit(X_train,Y_train.values.ravel())

# KNN with stemmed corpus
knn2 = KNeighborsClassifier(n_neighbors=3)
knn2.fit(X_train_stemmed,Y_train.values.ravel())

# comparing test values that generated by ctfidf and random forest without stemmed corpus
clf_predicted = pd.DataFrame(clf.predict(X_test))
print(metrics.classification_report(data_predicted,clf_predicted))
print(clf.score(X_test,Y_test))

# comparing test values that generated by ctfidf and random forest with stemmed corpus
clf2_predicted = pd.DataFrame(clf2.predict(X_test_stemmed))
print(metrics.classification_report(data_predicted,clf2_predicted))
print(clf2.score(X_test_stemmed,Y_test))

# comparing test values that generated by ctfidf and decision tree without stemmed corpus
dct_predicted = pd.DataFrame(dct.predict(X_test))
print(metrics.classification_report(data_predicted,dct_predicted))
print(dct.score(X_test,Y_test))

# comparing test values that generated by ctfidf and decision tree with stemmed corpus
dct2_predicted = pd.DataFrame(dct2.predict(X_test_stemmed))
print(metrics.classification_report(data_predicted,dct2_predicted))
print(dct2.score(X_test_stemmed,Y_test))

# comparing test values that generated by ctfidf and knn without stemmed corpus
knn_predicted = pd.DataFrame(knn.predict(X_test))
print(metrics.classification_report(data_predicted,knn_predicted))
print(knn.score(X_test,Y_test))

# comparing test values that generated by ctfidf and knn with stemmed corpus
knn2_predicted = pd.DataFrame(knn2.predict(X_test_stemmed))
print(metrics.classification_report(data_predicted,knn2_predicted))
print(knn2.score(X_test_stemmed,Y_test))










